# -*- coding: utf-8 -*-
"""DSA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16lQGLuCzM-Reyb7WHTIR2wyU4RZ3cw67

Problem 1: Reverse a singly linked list.
Input: 1 -> 2 -> 3 -> 4 -> 5
Output: 5 -> 4 -> 3 -> 2 -> 1
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

new_head = reverseList(head)
1
while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 2: Merge two sorted linked lists into one sorted linked list.
Input: List 1: 1 -> 3 -> 5, List 2: 2 -> 4 -> 6
Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    current = dummy

    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    current.next = l1 if l1 else l2
    return dummy.next

l1 = ListNode(1)
l1.next = ListNode(3)
l1.next.next = ListNode(5)

l2 = ListNode(2)
l2.next = ListNode(4)
l2.next.next = ListNode(6)

merged_head = mergeTwoLists(l1, l2)
while merged_head:
    print(merged_head.val, end=" -> " if merged_head.next else "\n")
    merged_head = merged_head.next

"""Problem 3: Remove the nth node from the end of a linked list.
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    dummy = ListNode(0)
    dummy.next = head
    first = second = dummy

    for _ in range(n + 1):
        first = first.next

    while first:
        first = first.next
        second = second.next

    second.next = second.next.next
    return dummy.next

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

n = 2
new_head = removeNthFromEnd(head, n)

while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 4: Find the intersection point of two linked lists.
Input: List 1: 1 -> 2 -> 3 -> 4, List 2: 9 -> 8 -> 3 -> 4
Output: Node with value 3
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getIntersectionNode(headA, headB):
    p1, p2 = headA, headB

    while p1 != p2:
        p1 = p1.next if p1 else headB
        p2 = p2.next if p2 else headA

    return p1

common = ListNode(3, ListNode(4))

headA = ListNode(1, ListNode(2, common))
headB = ListNode(9, ListNode(8, common))

intersection = getIntersectionNode(headA, headB)

print("Intersection Node:", intersection.val if intersection else "No Intersection")

"""Problem 5: Remove duplicates from a sorted linked list.
Input: 1 -> 1 -> 2 -> 3 -> 3
Output: 1 -> 2 -> 3
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeDuplicates(head):
    current = head
    while current and current.next:
        if current.val == current.next.val:
            current.next = current.next.next
        else:
            current = current.next
    return head

head = ListNode(1)
head.next = ListNode(1)
head.next.next = ListNode(2)
head.next.next.next = ListNode(3)
head.next.next.next.next = ListNode(3)

new_head = removeDuplicates(head)

while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 6: Add two numbers represented by linked lists (where each node contains a single digit).
Input: List 1: 2 -> 4 -> 3, List 2: 5 -> 6 -> 4 (represents 342 + 465)
Output: 7 -> 0 -> 8 (represents 807)

"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)

        current = current.next
        if l1: l1 = l1.next
        if l2: l2 = l2.next

    return dummy.next

l1 = ListNode(2)
l1.next = ListNode(4)
l1.next.next = ListNode(3)

l2 = ListNode(5)
l2.next = ListNode(6)
l2.next.next = ListNode(4)

result = addTwoNumbers(l1, l2)

while result:
    print(result.val, end=" -> " if result.next else "\n")
    result = result.next

"""Problem 7: Swap nodes in pairs in a linked list.
Input: 1 -> 2 -> 3 -> 4
Output: 2 -> 1 -> 4 -> 3
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head):
    dummy = ListNode(0)
    dummy.next = head
    current = dummy

    while current.next and current.next.next:
        first = current.next
        second = current.next.next

        first.next = second.next
        current.next = second
        second.next = first

        current = first

    return dummy.next

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)

new_head = swapPairs(head)

while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 8: Reverse nodes in a linked list in groups of k.
Input: 1 -> 2 -> 3 -> 4 -> 5, k = 3
Output: 3 -> 2 -> 1 -> 4 -> 5
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    def reverseLinkedList(head, k):
        prev = None
        current = head
        while k > 0:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
            k -= 1
        return prev
    dummy = ListNode(0)
    dummy.next = head
    group_prev = dummy

    while True:
        kth_node = group_prev
        for _ in range(k):
            kth_node = kth_node.next
            if not kth_node:
                return dummy.next

        group_next = kth_node.next
        group_start = group_prev.next
        kth_node.next = None
        group_prev.next = reverseLinkedList(group_start, k)
        group_start.next = group_next
        group_prev = group_start

    return dummy.next

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

k = 3

new_head = reverseKGroup(head, k)

while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 9: Determine if a linked list is a palindrome.
Input: 1 -> 2 -> 2 -> 1
Output: True
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def isPalindrome(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    prev = None
    while slow:
        next_node = slow.next
        slow.next = prev
        prev = slow
        slow = next_node

    left, right = head, prev
    while right:
        if left.val != right.val:
            return False
        left = left.next
        right = right.next

    return True

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(2)
head.next.next.next = ListNode(1)

result = isPalindrome(head)

print(result)

"""Problem 10: Rotate a linked list to the right by k places.
Input: 1 -> 2 -> 3 -> 4 -> 5, k = 2
Output: 4 -> 5 -> 1 -> 2 -> 3
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rotateRight(head, k):
    if not head or not head.next or k == 0:
        return head

    length = 1
    tail = head
    while tail.next:
        tail = tail.next
        length += 1

    tail.next = head

    k = k % length
    steps_to_new_head = length - k
    new_tail = head
    for _ in range(steps_to_new_head - 1):
        new_tail = new_tail.next

    new_head = new_tail.next
    new_tail.next = None

    return new_head

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

k = 2

new_head = rotateRight(head, k)
while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 11: Flatten a multilevel doubly linked list.
Input: 1 <-> 2 <-> 3 <-> 7 <-> 8 <-> 11 -> 12, 4 <-> 5 -> 9 -> 10, 6 -> 13
Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-> 7 <-> 8 <-> 9 <-> 10 <-> 11 <-> 12 <-> 13
"""

class Node:
    def __init__(self, val=0, prev=None, next=None, child=None):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child

def flatten(head):
    if not head:
        return head

    current = head
    while current:
        if current.child:
            child = current.child
            while child.next:
                child = child.next

            child.next = current.next
            if current.next:
                current.next.prev = child
            current.next = current.child
            if current.child:
                current.child.prev = current
            current.child = None

        current = current.next

    return head

head = Node(1)
head.next = Node(2, prev=head)
head.next.next = Node(3, prev=head.next)
head.next.next.next = Node(7, prev=head.next.next)
head.next.next.next.next = Node(8, prev=head.next.next.next)
head.next.next.next.next.next = Node(11, prev=head.next.next.next.next)
head.next.next.next.next.next.next = Node(12, prev=head.next.next.next.next.next)

head.next.child = Node(4)
head.next.child.next = Node(5, prev=head.next.child)
head.next.child.next.next = Node(9, prev=head.next.child.next)
head.next.child.next.next.next = Node(10, prev=head.next.child.next.next)

head.next.next.next.child = Node(6)
head.next.next.next.child.next = Node(13, prev=head.next.next.next.child)
flattened_head = flatten(head)

current = flattened_head
while current:
    print(current.val, end=" <-> " if current.next else "\n")
    current = current.next

"""Problem 12: Rearrange a linked list such that all even positioned nodes are placed at the end.
Input: 1 -> 2 -> 3 -> 4 -> 5
Output: 1 -> 3 -> 5 -> 2 -> 4
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rearrangeList(head):
    if not head or not head.next:
        return head

    odd_head = odd_tail = head
    even_head = even_tail = head.next
    current = head.next.next
    is_odd = True

    while current:
        if is_odd:
            odd_tail.next = current
            odd_tail = odd_tail.next
        else:
            even_tail.next = current
            even_tail = even_tail.next
        current = current.next
        is_odd = not is_odd
    even_tail.next = None
    odd_tail.next = even_head

    return odd_head
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)
new_head = rearrangeList(head)
while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 13: Given a non-negative number represented as a linked list, add one to it.
Input: 1 -> 2 -> 3 (represents the number 123)
Output: 1 -> 2 -> 4 (represents the number 124)
"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addOne(head):
    def reverseList(node):
        prev = None
        current = node
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        return prev

    head = reverseList(head)

    current = head
    carry = 1
    while current and carry:
        total = current.val + carry
        current.val = total % 10
        carry = total // 10
        if current.next is None and carry:
            current.next = ListNode(0)
        current = current.next

    head = reverseList(head)
    return head

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

new_head = addOne(head)

while new_head:
    print(new_head.val, end=" -> " if new_head.next else "\n")
    new_head = new_head.next

"""Problem 14: Given a sorted array and a target value, return the index if the target is found. If not, return the
index where it would be inserted.
Input: nums = [1, 3, 5, 6], target = 5
Output: 2
"""

def searchInsert(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return left
nums = [1, 3, 5, 6]
target = 5
index = searchInsert(nums, target)

print(index)

"""Problem 15: Find the minimum element in a rotated sorted array.
Input: [4, 5, 6, 7, 0, 1, 2]
Output: 0
"""

def findMin(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid

    return nums[left]

nums = [4, 5, 6, 7, 0, 1, 2]
print(findMin(nums))

"""Problem 16: Search for a target value in a rotated sorted array.
Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 0
Output: 4
"""

def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0

print(search(nums, target))

"""Problem 17: Find the peak element in an array. A peak element is greater than its neighbors.
Input: nums = [1, 2, 3, 1]
Output: 2 (index of peak element)
"""

def findPeakElement(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1

    return left

nums = [1, 2, 3, 1]

print(findPeakElement(nums))

"""Problem 18: Given a m x n matrix where each row and column is sorted in ascending order, count the number
of negative numbers.
Input: grid = [[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]
Output: 8
"""

def countNegatives(grid):
    m, n = len(grid), len(grid[0])
    count = 0
    row, col = m - 1, 0

    while row >= 0 and col < n:
        if grid[row][col] < 0:
            count += n - col
            row -= 1
        else:
            col += 1

    return count

grid = [[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]

print(countNegatives(grid))

"""Problem 19: Given a 2D matrix sorted in ascending order in each row, and the first integer of each row is
greater than the last integer of the previous row, determine if a target value is present in the matrix.
Input: matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], target = 3
Output: True
"""

def searchMatrix(matrix, target):
    if not matrix:
        return False

    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n - 1

    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // n][mid % n]

        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1

    return False

matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]
target = 3

print(searchMatrix(matrix, target))

"""Problem 20: Find Median in Two Sorted Arrays
Problem: Given two sorted arrays, find the median of the combined sorted array.
Input: nums1 = [1, 3], nums2 = [2]
Output: 2.0
"""

def findMedianSortedArrays(nums1, nums2):
    nums = nums1 + nums2
    nums.sort()
    n = len(nums)

    if n % 2 == 1:
        return float(nums[n // 2])
    else:
        return (nums[(n // 2) - 1] + nums[n // 2]) / 2

nums1 = [1, 3]
nums2 = [2]

print(findMedianSortedArrays(nums1, nums2))

"""Problem 21: Given a sorted character array and a target letter, find the smallest letter in the array that is
greater than the target.
Input: letters = ['c', 'f', 'j'], target = a
Output: 'c'
"""

def nextGreatestLetter(letters, target):
    left, right = 0, len(letters) - 1

    while left <= right:
        mid = (left + right) // 2
        if letters[mid] <= target:
            left = mid + 1
        else:
            right = mid - 1

    return letters[left % len(letters)]

letters = ['c', 'f', 'j']
target = 'a'

print(nextGreatestLetter(letters, target))

"""Problem 22: Given an array with n objects colored red, white, or blue, sort them in-place so that objects of
the same color are adjacent, with the colors in the order red, white, and blue.
Input: nums = [2, 0, 2, 1, 1, 0]
Output: [0, 0, 1, 1, 2, 2]
"""

def sortColors(nums):
    low, mid, high = 0, 0, len(nums) - 1

    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1

nums = [2, 0, 2, 1, 1, 0]

sortColors(nums)

print(nums)

"""Problem 23: Find the kth largest element in an unsorted array.
Input: nums = [3, 2, 1, 5, 6, 4], k = 2
Output: 5
"""

import heapq

def findKthLargest(nums, k):
    return heapq.nlargest(k, nums)[-1]

nums = [3, 2, 1, 5, 6, 4]
k = 2

print(findKthLargest(nums, k))

"""Problem 24: Given an unsorted array, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <=
nums[3]...
Input: nums = [3, 5, 2, 1, 6, 4]
Output: [3, 5, 1, 6, 2, 4]
"""

def wiggleSort(nums):
    for i in range(1, len(nums), 2):
        if i > 0 and nums[i] < nums[i - 1]:
            nums[i], nums[i - 1] = nums[i - 1], nums[i]
        if i < len(nums) - 1 and nums[i] < nums[i + 1]:
            nums[i], nums[i + 1] = nums[i + 1], nums[i]

nums = [3, 5, 2, 1, 6, 4]

wiggleSort(nums)

print(nums)

"""Problem 25: Given an array of integers, calculate the sum of all its elements.
Input: [1, 2, 3, 4, 5]
Output: 15
"""

def arraySum(nums):
    return sum(nums)

nums = [1, 2, 3, 4, 5]

print(arraySum(nums))

"""Problem 26: Find the maximum element in an array of integers.
Input: [3, 7, 2, 9, 4, 1]
Output: 9
"""

def findMax(nums):
    return max(nums)

nums = [3, 7, 2, 9, 4, 1]

print(findMax(nums))

"""Problem 27: Implement linear search to find the index of a target element in an array.
Input: [5, 3, 8, 2, 7, 4], target = 8
Output: 2
"""

def linearSearch(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1

nums = [5, 3, 8, 2, 7, 4]
target = 8

print(linearSearch(nums, target))

"""Problem 28 Calculate the factorial of a given number.
Input: 5
Output: 120 (as 5! = 5 * 4 * 3 * 2 * 1 = 120)
"""

def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

n = 5

print(factorial(n))

"""Problem 29: Check if a given number is a prime number.
Input: 7
Output: True
"""

def isPrime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

n = 7

print(isPrime(n))

"""Problem 30: Generate the Fibonacci series up to a given number n.
Input: 8
Output: [0, 1, 1, 2, 3, 5, 8, 13]
"""

def fibonacci(n):
    fib_series = [0, 1]
    while len(fib_series) < n:
        fib_series.append(fib_series[-1] + fib_series[-2])
    return fib_series[:n]

n = 8

print(fibonacci(n))

"""Problem 31: Calculate the power of a number using recursion.
Input: base = 3, exponent = 4
Output: 81 (as 3^4 = 3 * 3 * 3 * 3 = 81)
"""

def power(base, exponent):
    if exponent == 0:
        return 1
    return base * power(base, exponent - 1)

base = 3
exponent = 4

print(power(base, exponent))

"""Problem 32: Reverse a given string.
Input: "hello"
Output: "olleh"
"""

def reverseString(s):
    return s[::-1]

s = "hello"

print(reverseString(s))